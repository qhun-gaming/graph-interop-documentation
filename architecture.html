<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#647A89"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-11-28T20:38:40.447621553"><title>Architecture | GraphInterop</title><script type="application/json" id="virtual-toc-data">[{"id":"overview","level":0,"title":"Overview","anchor":"#overview"},{"id":"high-level-architecture","level":0,"title":"High-Level Architecture","anchor":"#high-level-architecture"},{"id":"assembly-structure","level":0,"title":"Assembly Structure","anchor":"#assembly-structure"},{"id":"design-principles","level":0,"title":"Design Principles","anchor":"#design-principles"},{"id":"core-components","level":0,"title":"Core Components","anchor":"#core-components"},{"id":"data-flow","level":0,"title":"Data Flow","anchor":"#data-flow"},{"id":"type-system","level":0,"title":"Type System","anchor":"#type-system"},{"id":"editor-backend-architecture","level":0,"title":"Editor Backend Architecture","anchor":"#editor-backend-architecture"},{"id":"performance-considerations","level":0,"title":"Performance Considerations","anchor":"#performance-considerations"},{"id":"thread-safety","level":0,"title":"Thread Safety","anchor":"#thread-safety"},{"id":"memory-management","level":0,"title":"Memory Management","anchor":"#memory-management"},{"id":"extension-points","level":0,"title":"Extension Points","anchor":"#extension-points"},{"id":"summary","level":0,"title":"Summary","anchor":"#summary"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.25.3-b857/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Architecture | GraphInterop"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="GraphInterop Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/architecture.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Architecture | GraphInterop"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/architecture.html#webpage",
    "url": "writerside-documentation/architecture.html",
    "name": "Architecture | GraphInterop",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "GraphInterop Help"
}</script><!-- End Schema.org --></head><body data-id="architecture" data-main-title="Architecture" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>GraphInterop  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="architecture" id="architecture.md">Architecture</h1><p id="-6qkyo6_3">GraphInterop follows a layered architecture that separates runtime logic from editor visualization, enabling flexibility and maintainability.</p><section class="chapter"><h2 id="overview" data-toc="overview">Overview</h2><p id="-6qkyo6_17">GraphInterop's architecture is built on three core principles:</p><ol class="list _decimal" id="-6qkyo6_18" type="1"><li class="list__item" id="-6qkyo6_19"><p id="-6qkyo6_22"><span class="control" id="-6qkyo6_23">Runtime/Editor Separation</span>: Runtime graph execution has zero editor dependencies</p></li><li class="list__item" id="-6qkyo6_20"><p id="-6qkyo6_24"><span class="control" id="-6qkyo6_25">Backend Abstraction</span>: Multiple visual editors can be plugged in without changing user code</p></li><li class="list__item" id="-6qkyo6_21"><p id="-6qkyo6_26"><span class="control" id="-6qkyo6_27">GraphToolkit API Compatibility</span>: Runtime API mirrors Unity's GraphToolkit for future compatibility</p></li></ol></section><section class="chapter"><h2 id="high-level-architecture" data-toc="high-level-architecture">High-Level Architecture</h2><div class="code-block" data-lang="none">
┌─────────────────────────────────────────┐
│        User Code (Your Nodes)          │
│    MyCustomNode, GameLogicNode, etc.   │
└──────────────┬──────────────────────────┘
               │ depends on
               ▼
┌─────────────────────────────────────────┐
│      GraphInterop Runtime API           │
│  GraphAsset, GraphNode, GraphExecutor   │
│         (Semver-Stable API)             │
└──────────────┬──────────────────────────┘
               │
        ┌──────┴──────┐
        ▼             ▼
┌──────────────┐ ┌──────────────┐
│  GraphView   │ │ GraphToolkit │
│   Backend    │ │   Backend    │
│  (Current)   │ │   (Future)   │
└──────────────┘ └──────────────┘
</div><section class="chapter"><h3 id="key-insight" data-toc="key-insight">Key Insight</h3><p id="-6qkyo6_30">Your custom nodes only depend on the stable <code class="code" id="-6qkyo6_31">QhunGaming.GraphInterop</code> API. The visual backend (GraphView/GraphToolkit) can change without breaking your code.</p></section></section><section class="chapter"><h2 id="assembly-structure" data-toc="assembly-structure">Assembly Structure</h2><p id="-6qkyo6_32">GraphInterop consists of two assemblies:</p><section class="chapter"><h3 id="runtime-assembly" data-toc="runtime-assembly">Runtime Assembly</h3><p id="-6qkyo6_35"><span class="control" id="-6qkyo6_42">Name</span>: <code class="code" id="-6qkyo6_43">QhunGaming.GraphInterop</code></p><p id="-6qkyo6_36"><span class="control" id="-6qkyo6_44">Purpose</span>: All graph execution logic, no editor dependencies</p><p id="-6qkyo6_37"><span class="control" id="-6qkyo6_45">Key Types:</span></p><ul class="list _bullet" id="-6qkyo6_38"><li class="list__item" id="-6qkyo6_46"><p id="-6qkyo6_53"><code class="code" id="-6qkyo6_54">GraphAsset</code> - Graph data container (ScriptableObject)</p></li><li class="list__item" id="-6qkyo6_47"><p id="-6qkyo6_55"><code class="code" id="-6qkyo6_56">GraphNode</code> - Base class for all nodes</p></li><li class="list__item" id="-6qkyo6_48"><p id="-6qkyo6_57"><code class="code" id="-6qkyo6_58">GraphExecutor</code> - Executes graphs</p></li><li class="list__item" id="-6qkyo6_49"><p id="-6qkyo6_59"><code class="code" id="-6qkyo6_60">GraphContext</code> - Execution context</p></li><li class="list__item" id="-6qkyo6_50"><p id="-6qkyo6_61"><code class="code" id="-6qkyo6_62">IPort</code>, <code class="code" id="-6qkyo6_63">INodeOption</code> - Port/option interfaces</p></li><li class="list__item" id="-6qkyo6_51"><p id="-6qkyo6_64">Port/Option builders - Fluent configuration API</p></li><li class="list__item" id="-6qkyo6_52"><p id="-6qkyo6_65"><code class="code" id="-6qkyo6_66">TypeCompatibility</code> - Type system utilities</p></li></ul><p id="-6qkyo6_39"><span class="control" id="-6qkyo6_67">Dependencies:</span></p><ul class="list _bullet" id="-6qkyo6_40"><li class="list__item" id="-6qkyo6_68"><p id="-6qkyo6_72">Unity Engine (runtime only)</p></li><li class="list__item" id="-6qkyo6_69"><p id="-6qkyo6_73">Unity Mathematics (optional, for Burst)</p></li><li class="list__item" id="-6qkyo6_70"><p id="-6qkyo6_74">Unity Burst (optional)</p></li><li class="list__item" id="-6qkyo6_71"><p id="-6qkyo6_75">Unity Addressables (optional, for async examples)</p></li></ul><p id="-6qkyo6_41"><span class="control" id="-6qkyo6_76">Platform</span>: All (works in builds and editor)</p></section><section class="chapter"><h3 id="editor-assembly" data-toc="editor-assembly">Editor Assembly</h3><p id="-6qkyo6_77"><span class="control" id="-6qkyo6_84">Name</span>: <code class="code" id="-6qkyo6_85">QhunGaming.GraphInterop.Editor</code></p><p id="-6qkyo6_78"><span class="control" id="-6qkyo6_86">Purpose</span>: Visual graph editing using GraphView</p><p id="-6qkyo6_79"><span class="control" id="-6qkyo6_87">Key Types:</span></p><ul class="list _bullet" id="-6qkyo6_80"><li class="list__item" id="-6qkyo6_88"><p id="-6qkyo6_96"><code class="code" id="-6qkyo6_97">GraphInteropEditorWindow</code> - Main editor window</p></li><li class="list__item" id="-6qkyo6_89"><p id="-6qkyo6_98"><code class="code" id="-6qkyo6_99">IGraphEditorBackend</code> - Backend abstraction interface</p></li><li class="list__item" id="-6qkyo6_90"><p id="-6qkyo6_100"><code class="code" id="-6qkyo6_101">GraphViewEditorBackend</code> - GraphView implementation</p></li><li class="list__item" id="-6qkyo6_91"><p id="-6qkyo6_102"><code class="code" id="-6qkyo6_103">InteropGraphView</code> - GraphView subclass</p></li><li class="list__item" id="-6qkyo6_92"><p id="-6qkyo6_104"><code class="code" id="-6qkyo6_105">InteropNodeView</code> - Node visualization</p></li><li class="list__item" id="-6qkyo6_93"><p id="-6qkyo6_106"><code class="code" id="-6qkyo6_107">InteropPort</code> - Port visualization</p></li><li class="list__item" id="-6qkyo6_94"><p id="-6qkyo6_108"><code class="code" id="-6qkyo6_109">InteropBlackboard</code> - Parameter panel</p></li><li class="list__item" id="-6qkyo6_95"><p id="-6qkyo6_110"><code class="code" id="-6qkyo6_111">InteropInspector</code> - Selection details panel</p></li></ul><p id="-6qkyo6_81"><span class="control" id="-6qkyo6_112">Dependencies:</span></p><ul class="list _bullet" id="-6qkyo6_82"><li class="list__item" id="-6qkyo6_113"><p id="-6qkyo6_117">Runtime assembly</p></li><li class="list__item" id="-6qkyo6_114"><p id="-6qkyo6_118">Unity Editor</p></li><li class="list__item" id="-6qkyo6_115"><p id="-6qkyo6_119">Unity UIElements</p></li><li class="list__item" id="-6qkyo6_116"><p id="-6qkyo6_120">GraphView (part of UIElements)</p></li></ul><p id="-6qkyo6_83"><span class="control" id="-6qkyo6_121">Platform</span>: Editor only</p></section></section><section class="chapter"><h2 id="design-principles" data-toc="design-principles">Design Principles</h2><section class="chapter"><h3 id="1-runtime-editor-separation" data-toc="1-runtime-editor-separation">1. Runtime/Editor Separation</h3><p id="-6qkyo6_125"><span class="control" id="-6qkyo6_130">Goal</span>: Graphs can execute in builds without editor dependencies</p><p id="-6qkyo6_126"><span class="control" id="-6qkyo6_131">Implementation:</span></p><div class="code-block" data-lang="csharp">
// Runtime assembly (no editor dependencies)
namespace QhunGaming.GraphInterop
{
    public abstract class GraphNode : ScriptableObject
    {
        public abstract void Process(GraphContext context);
    }
}

// Editor assembly (uses UnityEditor)
#if UNITY_EDITOR
namespace QhunGaming.GraphInterop.Editor
{
    public class InteropNodeView : Node
    {
        public InteropNodeView(GraphNode model) { }
    }
}
#endif
</div><p id="-6qkyo6_128"><span class="control" id="-6qkyo6_132">Benefits:</span></p><ul class="list _bullet" id="-6qkyo6_129"><li class="list__item" id="-6qkyo6_133"><p id="-6qkyo6_137">Graphs run in builds</p></li><li class="list__item" id="-6qkyo6_134"><p id="-6qkyo6_138">No editor bloat in builds</p></li><li class="list__item" id="-6qkyo6_135"><p id="-6qkyo6_139">Faster build times</p></li><li class="list__item" id="-6qkyo6_136"><p id="-6qkyo6_140">Smaller binary size</p></li></ul></section><section class="chapter"><h3 id="2-backend-abstraction" data-toc="2-backend-abstraction">2. Backend Abstraction</h3><p id="-6qkyo6_141"><span class="control" id="-6qkyo6_146">Goal</span>: Support multiple visual editors (GraphView, GraphToolkit, custom)</p><p id="-6qkyo6_142"><span class="control" id="-6qkyo6_147">Implementation:</span></p><div class="code-block" data-lang="csharp">
public interface IGraphEditorBackend
{
    GraphAsset CurrentGraph { get; }
    void Initialize(EditorWindow window, VisualElement root);
    void LoadGraph(GraphAsset graph);
    void OnDisable();
}

// GraphView implementation
public class GraphViewEditorBackend : IGraphEditorBackend { }

// Future GraphToolkit implementation
public class GraphToolkitEditorBackend : IGraphEditorBackend { }

// Registration (factory pattern)
[InitializeOnLoadMethod]
private static void RegisterBackends()
{
    GraphInteropEditorWindow.RegisterBackend(() =&gt; new GraphViewEditorBackend());
}
</div><p id="-6qkyo6_144"><span class="control" id="-6qkyo6_148">Benefits:</span></p><ul class="list _bullet" id="-6qkyo6_145"><li class="list__item" id="-6qkyo6_149"><p id="-6qkyo6_153">Easy to switch backends</p></li><li class="list__item" id="-6qkyo6_150"><p id="-6qkyo6_154">Future-proof (when GraphToolkit UI matures)</p></li><li class="list__item" id="-6qkyo6_151"><p id="-6qkyo6_155">Custom editors possible</p></li><li class="list__item" id="-6qkyo6_152"><p id="-6qkyo6_156">No user code changes needed</p></li></ul></section><section class="chapter"><h3 id="3-graphtoolkit-api-compatibility" data-toc="3-graphtoolkit-api-compatibility">3. GraphToolkit API Compatibility</h3><p id="-6qkyo6_157"><span class="control" id="-6qkyo6_162">Goal</span>: Match GraphToolkit's API design for familiarity and future migration</p><p id="-6qkyo6_158"><span class="control" id="-6qkyo6_163">Comparison:</span></p><div class="table-wrapper"><table class="wide" id="-6qkyo6_159"><thead><tr class="ijRowHead" id="-6qkyo6_164"><th id="-6qkyo6_170"><p>Aspect</p></th><th id="-6qkyo6_171"><p>GraphToolkit</p></th><th id="-6qkyo6_172"><p>GraphInterop</p></th></tr></thead><tbody><tr id="-6qkyo6_165"><td id="-6qkyo6_173"><p>Graph container</p></td><td id="-6qkyo6_174"><p><code class="code" id="-6qkyo6_176">Graph</code> (abstract)</p></td><td id="-6qkyo6_175"><p><code class="code" id="-6qkyo6_177">GraphAsset</code> (concrete ScriptableObject)</p></td></tr><tr id="-6qkyo6_166"><td id="-6qkyo6_178"><p>Node definition</p></td><td id="-6qkyo6_179"><p><code class="code" id="-6qkyo6_181">OnDefinePorts()</code></p></td><td id="-6qkyo6_180"><p><code class="code" id="-6qkyo6_182">OnDefinePorts()</code> ✅ Same</p></td></tr><tr id="-6qkyo6_167"><td id="-6qkyo6_183"><p>Port builders</p></td><td id="-6qkyo6_184"><p><code class="code" id="-6qkyo6_186">IPortBuilder&lt;T&gt;</code></p></td><td id="-6qkyo6_185"><p><code class="code" id="-6qkyo6_187">IPortBuilder&lt;T&gt;</code> ✅ Same</p></td></tr><tr id="-6qkyo6_168"><td id="-6qkyo6_188"><p>Options</p></td><td id="-6qkyo6_189"><p><code class="code" id="-6qkyo6_191">INodeOption</code></p></td><td id="-6qkyo6_190"><p><code class="code" id="-6qkyo6_192">INodeOption</code> ✅ Same</p></td></tr><tr id="-6qkyo6_169"><td id="-6qkyo6_193"><p>Variables</p></td><td id="-6qkyo6_194"><p><code class="code" id="-6qkyo6_196">IVariable</code></p></td><td id="-6qkyo6_195"><p><code class="code" id="-6qkyo6_197">GraphParameter</code> (similar)</p></td></tr></tbody></table></div><p id="-6qkyo6_160"><span class="control" id="-6qkyo6_198">Benefits:</span></p><ul class="list _bullet" id="-6qkyo6_161"><li class="list__item" id="-6qkyo6_199"><p id="-6qkyo6_203">Familiar API for GTK users</p></li><li class="list__item" id="-6qkyo6_200"><p id="-6qkyo6_204">Easier future migration</p></li><li class="list__item" id="-6qkyo6_201"><p id="-6qkyo6_205">Consistent patterns</p></li><li class="list__item" id="-6qkyo6_202"><p id="-6qkyo6_206">Official Unity direction</p></li></ul></section></section><section class="chapter"><h2 id="core-components" data-toc="core-components">Core Components</h2><section class="chapter"><h3 id="graphasset-graph-data-model" data-toc="graphasset-graph-data-model">GraphAsset (Graph Data Model)</h3><p id="-6qkyo6_212"><span class="control" id="-6qkyo6_219">Purpose</span>: Serializable container for graph structure</p><p id="-6qkyo6_213"><span class="control" id="-6qkyo6_220">Responsibilities:</span></p><ul class="list _bullet" id="-6qkyo6_214"><li class="list__item" id="-6qkyo6_221"><p id="-6qkyo6_225">Store nodes, connections, parameters</p></li><li class="list__item" id="-6qkyo6_222"><p id="-6qkyo6_226">Validate graph structure</p></li><li class="list__item" id="-6qkyo6_223"><p id="-6qkyo6_227">Define context variables</p></li><li class="list__item" id="-6qkyo6_224"><p id="-6qkyo6_228">Provide CRUD operations</p></li></ul><p id="-6qkyo6_215"><span class="control" id="-6qkyo6_229">Key Properties:</span></p><div class="code-block" data-lang="csharp">
public class GraphAsset : ScriptableObject
{
    // Node storage
    [SerializeReference] public List&lt;GraphNode&gt; Nodes;

    // Connection storage
    [SerializeField] public List&lt;Connection&gt; Connections;

    // Parameter storage
    [SerializeField] public Blackboard Blackboard;

    // Context variable definitions
    public virtual IEnumerable&lt;ContextVariableDefinition&gt; GetContextVariables();

    // Operations
    public T AddNode&lt;T&gt;() where T : GraphNode;
    public void RemoveNode(GraphNode node);
    public void Connect(GraphNode source, string sourcePort,
                       GraphNode target, string targetPort);
    public List&lt;string&gt; Validate();
}
</div><p id="-6qkyo6_217"><span class="control" id="-6qkyo6_230">Serialization:</span></p><ul class="list _bullet" id="-6qkyo6_218"><li class="list__item" id="-6qkyo6_231"><p id="-6qkyo6_234">Uses <code class="code" id="-6qkyo6_235">[SerializeReference]</code> for polymorphic nodes</p></li><li class="list__item" id="-6qkyo6_232"><p id="-6qkyo6_236">Connection stored by node ID (string references)</p></li><li class="list__item" id="-6qkyo6_233"><p id="-6qkyo6_237">ScriptableObject for Unity asset integration</p></li></ul></section><section class="chapter"><h3 id="graphnode-node-definition" data-toc="graphnode-node-definition">GraphNode (Node Definition)</h3><p id="-6qkyo6_238"><span class="control" id="-6qkyo6_245">Purpose</span>: Base class for all custom nodes</p><p id="-6qkyo6_239"><span class="control" id="-6qkyo6_246">Responsibilities:</span></p><ul class="list _bullet" id="-6qkyo6_240"><li class="list__item" id="-6qkyo6_247"><p id="-6qkyo6_250">Define ports via builder pattern</p></li><li class="list__item" id="-6qkyo6_248"><p id="-6qkyo6_251">Define options via builder pattern</p></li><li class="list__item" id="-6qkyo6_249"><p id="-6qkyo6_252">Execute logic in <code class="code" id="-6qkyo6_253">Process()</code></p></li></ul><p id="-6qkyo6_241"><span class="control" id="-6qkyo6_254">Key Methods:</span></p><div class="code-block" data-lang="csharp">
public abstract class GraphNode : ScriptableObject
{
    // Unique identifier
    public string Id { get; internal set; }

    // Editor position (not used at runtime)
    public Vector2 EditorPosition { get; set; }

    // Port definition (builder pattern)
    protected virtual void OnDefinePorts(IPortDefinitionContext context) { }

    // Option definition (builder pattern)
    protected virtual void OnDefineOptions(IOptionDefinitionContext context) { }

    // Execution (override in subclasses)
    public abstract void Process(GraphContext context);

    // Port access
    public IPort GetInputPort(string name);
    public IPort GetOutputPort(string name);
    public IEnumerable&lt;IPort&gt; GetInputPorts();
    public IEnumerable&lt;IPort&gt; GetOutputPorts();

    // Option access
    public INodeOption GetNodeOption(string name);
    public T GetOptionValue&lt;T&gt;(string name);

    // Lifecycle
    public virtual void OnEnable() { }
    public virtual void OnDisable() { }

    // Validation
    public virtual void Validate(List&lt;string&gt; errors) { }
}
</div><p id="-6qkyo6_243"><span class="control" id="-6qkyo6_255">Lifecycle:</span></p><ol class="list _decimal" id="-6qkyo6_244" type="1"><li class="list__item" id="-6qkyo6_256"><p id="-6qkyo6_260"><span class="control" id="-6qkyo6_261">Creation</span>: <code class="code" id="-6qkyo6_262">graph.AddNode&lt;T&gt;()</code> &rarr; ScriptableObject.CreateInstance</p></li><li class="list__item" id="-6qkyo6_257"><p id="-6qkyo6_263"><span class="control" id="-6qkyo6_264">Definition</span>: First port/option access &rarr; <code class="code" id="-6qkyo6_265">OnDefinePorts()</code>/<code class="code" id="-6qkyo6_266">OnDefineOptions()</code></p></li><li class="list__item" id="-6qkyo6_258"><p id="-6qkyo6_267"><span class="control" id="-6qkyo6_268">Execution</span>: <code class="code" id="-6qkyo6_269">GraphExecutor</code> calls <code class="code" id="-6qkyo6_270">Process(context)</code></p></li><li class="list__item" id="-6qkyo6_259"><p id="-6qkyo6_271"><span class="control" id="-6qkyo6_272">Destruction</span>: Removed from graph &rarr; DestroyImmediate</p></li></ol></section><section class="chapter"><h3 id="port-system" data-toc="port-system">Port System</h3><p id="-6qkyo6_273"><span class="control" id="-6qkyo6_282">Purpose</span>: Type-safe input/output definition</p><p id="-6qkyo6_274"><span class="control" id="-6qkyo6_283">Key Interfaces:</span></p><div class="code-block" data-lang="csharp">
public interface IPort
{
    string name { get; }
    string displayName { get; }
    Type dataType { get; }
    PortDirection direction { get; }
    bool isConnected { get; }
    object DefaultValue { get; }
    object EmbeddedValue { get; set; }
}

public enum PortDirection
{
    Input,
    Output
}
</div><p id="-6qkyo6_276"><span class="control" id="-6qkyo6_284">Builder Pattern:</span></p><div class="code-block" data-lang="csharp">
// Input port builder
public interface IInputPortBuilder&lt;T&gt; : IInputPortBuilder
{
    IInputPortBuilder&lt;T&gt; WithDisplayName(string displayName);
    IInputPortBuilder&lt;T&gt; WithDefaultValue(T defaultValue);
    IInputPortBuilder&lt;T&gt; Required();
    void Build();
}

// Output port builder
public interface IOutputPortBuilder&lt;T&gt; : IOutputPortBuilder
{
    IOutputPortBuilder&lt;T&gt; WithDisplayName(string displayName);
    void Build();
}
</div><p id="-6qkyo6_278"><span class="control" id="-6qkyo6_285">Port Definition Context:</span></p><div class="code-block" data-lang="csharp">
public interface IPortDefinitionContext
{
    IInputPortBuilder&lt;T&gt; AddInputPort&lt;T&gt;(string name);
    IInputPortBuilder AddInputPort(string name);
    IOutputPortBuilder&lt;T&gt; AddOutputPort&lt;T&gt;(string name);
    IOutputPortBuilder AddOutputPort(string name);
}
</div><p id="-6qkyo6_280"><span class="control" id="-6qkyo6_286">Usage Example:</span></p><div class="code-block" data-lang="csharp">
protected override void OnDefinePorts(IPortDefinitionContext context)
{
    context.AddInputPort&lt;float&gt;(&quot;speed&quot;)
        .WithDisplayName(&quot;Movement Speed&quot;)
        .WithDefaultValue(5.0f)
        .Required()
        .Build();

    context.AddOutputPort&lt;Vector3&gt;(&quot;velocity&quot;)
        .WithDisplayName(&quot;Velocity&quot;)
        .Build();
}
</div></section><section class="chapter"><h3 id="graphexecutor-execution-engine" data-toc="graphexecutor-execution-engine">GraphExecutor (Execution Engine)</h3><p id="-6qkyo6_287"><span class="control" id="-6qkyo6_296">Purpose</span>: Execute graphs in correct dependency order</p><p id="-6qkyo6_288"><span class="control" id="-6qkyo6_297">Responsibilities:</span></p><ul class="list _bullet" id="-6qkyo6_289"><li class="list__item" id="-6qkyo6_298"><p id="-6qkyo6_303">Topological sort of nodes</p></li><li class="list__item" id="-6qkyo6_299"><p id="-6qkyo6_304">Input value resolution</p></li><li class="list__item" id="-6qkyo6_300"><p id="-6qkyo6_305">Node execution (sync/async/Burst)</p></li><li class="list__item" id="-6qkyo6_301"><p id="-6qkyo6_306">Output value caching</p></li><li class="list__item" id="-6qkyo6_302"><p id="-6qkyo6_307">Error handling</p></li></ul><p id="-6qkyo6_290"><span class="control" id="-6qkyo6_308">Key Methods:</span></p><div class="code-block" data-lang="csharp">
public class GraphExecutor
{
    private readonly GraphAsset _graph;

    public GraphExecutor(GraphAsset graph) { _graph = graph; }

    // Execute graph
    public async Task ExecuteAsync(GraphContext context);

    // Topological sort (dependency order)
    private List&lt;GraphNode&gt; TopologicalSort();

    // Execute single node
    private async Task ExecuteNodeAsync(GraphNode node, GraphContext context);
}
</div><p id="-6qkyo6_292"><span class="control" id="-6qkyo6_309">Execution Flow:</span></p><section class="procedure-steps"><h3 id="execution-steps" data-toc="execution-steps">Graph Execution Steps</h3><ol class="list _decimal"><li class="list__item" id="-6qkyo6_310"><p><b id="-6qkyo6_314">Validation</b>: Check required inputs, cycles, context variables</p></li><li class="list__item" id="-6qkyo6_311"><p><b id="-6qkyo6_315">Topological Sort</b>: Order nodes by dependencies (includes portal dependencies)</p></li><li class="list__item" id="-6qkyo6_312"><p><b id="-6qkyo6_316">For Each Node (in order)</b>: </p><ul class="list _bullet" id="-6qkyo6_317"><li class="list__item" id="-6qkyo6_318"><p>Resolve input values (from connections or defaults)</p></li><li class="list__item" id="-6qkyo6_319"><p>Execute node logic (sync/async/Burst)</p></li><li class="list__item" id="-6qkyo6_320"><p>Cache output values in context</p></li></ul></li><li class="list__item" id="-6qkyo6_313"><p><b id="-6qkyo6_321">Completion</b>: All nodes processed</p></li></ol></section><p id="-6qkyo6_294"><span class="control" id="-6qkyo6_322">Topological Sort Algorithm:</span></p><div class="code-block" data-lang="csharp">
private List&lt;GraphNode&gt; TopologicalSort()
{
    var sorted = new List&lt;GraphNode&gt;();
    var visited = new HashSet&lt;string&gt;();
    var visiting = new HashSet&lt;string&gt;();

    foreach (var node in _graph.Nodes)
    {
        Visit(node, visited, visiting, sorted);
    }

    return sorted;
}

private void Visit(GraphNode node, HashSet&lt;string&gt; visited,
                   HashSet&lt;string&gt; visiting, List&lt;GraphNode&gt; sorted)
{
    if (visited.Contains(node.Id)) return;

    if (visiting.Contains(node.Id))
        throw new Exception(&quot;Cycle detected&quot;);

    visiting.Add(node.Id);

    // Visit dependencies (nodes connected to inputs)
    foreach (var connection in GetInputConnections(node))
    {
        var dependency = GetNode(connection.SourceNodeId);
        Visit(dependency, visited, visiting, sorted);
    }

    visiting.Remove(node.Id);
    visited.Add(node.Id);
    sorted.Add(node);
}
</div></section><section class="chapter"><h3 id="graphcontext-execution-context" data-toc="graphcontext-execution-context">GraphContext (Execution Context)</h3><p id="-6qkyo6_323"><span class="control" id="-6qkyo6_330">Purpose</span>: Carry data and services between nodes during execution</p><p id="-6qkyo6_324"><span class="control" id="-6qkyo6_331">Responsibilities:</span></p><ul class="list _bullet" id="-6qkyo6_325"><li class="list__item" id="-6qkyo6_332"><p id="-6qkyo6_335">Store input/output values</p></li><li class="list__item" id="-6qkyo6_333"><p id="-6qkyo6_336">Provide context variables</p></li><li class="list__item" id="-6qkyo6_334"><p id="-6qkyo6_337">Carry services (graph asset, etc.)</p></li></ul><p id="-6qkyo6_326"><span class="control" id="-6qkyo6_338">Key Properties:</span></p><div class="code-block" data-lang="csharp">
public class GraphContext
{
    // Value storage (key: nodeId.portName)
    private Dictionary&lt;string, object&gt; _values;

    // Context variables (runtime-provided)
    private Dictionary&lt;string, object&gt; _contextVariables;

    // Set/get values
    public void SetValue(string key, object value);
    public T GetValue&lt;T&gt;(string key);
    public bool TryGetValue&lt;T&gt;(string key, out T value);

    // Context variables
    public void SetContextVariable(string name, object value);
    public T GetContextVariable&lt;T&gt;(string name);

    // Services
    public GraphAsset GraphAsset { get; set; }
}
</div><p id="-6qkyo6_328"><span class="control" id="-6qkyo6_339">Value Key Format:</span></p><div class="code-block" data-lang="csharp">
// Input values
$&quot;{nodeId}.{portName}.input&quot;

// Output values
$&quot;{nodeId}.{portName}&quot;

// Example
&quot;node_123.velocity.input&quot;  // Input value for 'velocity' port
&quot;node_123.result&quot;          // Output value for 'result' port
</div></section></section><section class="chapter"><h2 id="data-flow" data-toc="data-flow">Data Flow</h2><section class="chapter"><h3 id="connection-model" data-toc="connection-model">Connection Model</h3><p id="-6qkyo6_343"><span class="control" id="-6qkyo6_348">Purpose</span>: Represent edges between ports</p><p id="-6qkyo6_344"><span class="control" id="-6qkyo6_349">Structure:</span></p><div class="code-block" data-lang="csharp">
[Serializable]
public struct Connection
{
    public string SourceNodeId;    // Output node ID
    public string SourcePortName;  // Output port name
    public string TargetNodeId;    // Input node ID
    public string TargetPortName;  // Input port name
}
</div><p id="-6qkyo6_346"><span class="control" id="-6qkyo6_350">No Object References:</span></p><ul class="list _bullet" id="-6qkyo6_347"><li class="list__item" id="-6qkyo6_351"><p id="-6qkyo6_354">Connections store string IDs, not object references</p></li><li class="list__item" id="-6qkyo6_352"><p id="-6qkyo6_355">Allows serialization without breaking references</p></li><li class="list__item" id="-6qkyo6_353"><p id="-6qkyo6_356">Nodes can be destroyed/recreated safely</p></li></ul></section><section class="chapter"><h3 id="value-resolution" data-toc="value-resolution">Value Resolution</h3><p id="-6qkyo6_357"><span class="control" id="-6qkyo6_361">Priority Order (Highest to Lowest):</span></p><ol class="list _decimal" id="-6qkyo6_358" type="1"><li class="list__item" id="-6qkyo6_362"><p id="-6qkyo6_365"><span class="control" id="-6qkyo6_367">Connected Value</span> (from source node output)</p><div class="code-block" data-lang="csharp">
var connectionValue = context.GetValue&lt;float&gt;($&quot;{sourceNodeId}.{sourcePortName}&quot;);
</div></li><li class="list__item" id="-6qkyo6_363"><p id="-6qkyo6_368"><span class="control" id="-6qkyo6_370">Embedded Value</span> (user-set in editor)</p><div class="code-block" data-lang="csharp">
var embeddedValue = port.EmbeddedValue;
</div></li><li class="list__item" id="-6qkyo6_364"><p id="-6qkyo6_371"><span class="control" id="-6qkyo6_373">Default Value</span> (defined in port builder)</p><div class="code-block" data-lang="csharp">
var defaultValue = port.DefaultValue;
</div></li></ol><p id="-6qkyo6_359"><span class="control" id="-6qkyo6_374">Resolution Logic:</span></p><div class="code-block" data-lang="csharp">
private object ResolveInputValue(GraphNode node, IPort port, GraphContext context)
{
    // Check for connection
    var connection = _graph.Connections.FirstOrDefault(c =&gt;
        c.TargetNodeId == node.Id &amp;&amp; c.TargetPortName == port.name
    );

    if (connection != null)
    {
        // Use connected value
        var key = $&quot;{connection.SourceNodeId}.{connection.SourcePortName}&quot;;
        return context.GetValue&lt;object&gt;(key);
    }

    // Use embedded or default value
    return port.EmbeddedValue ?? port.DefaultValue;
}
</div></section><section class="chapter"><h3 id="portal-data-flow" data-toc="portal-data-flow">Portal Data Flow</h3><p id="-6qkyo6_375"><span class="control" id="-6qkyo6_379">Portal Dependency:</span></p><div class="code-block" data-lang="csharp">
// Before topological sort, add portal dependencies
foreach (var receivePortal in _graph.GetNodes&lt;ReceivePortalNode&gt;())
{
    var portalId = receivePortal.GetOptionValue&lt;string&gt;(&quot;portalId&quot;);
    var sendPortal = _graph.FindNode&lt;SendPortalNode&gt;(n =&gt;
        n.GetOptionValue&lt;string&gt;(&quot;portalId&quot;) == portalId
    );

    if (sendPortal != null)
    {
        // Ensure ReceivePortal depends on SendPortal
        AddVirtualDependency(receivePortal, sendPortal);
    }
}
</div><p id="-6qkyo6_377"><span class="control" id="-6qkyo6_380">Value Transfer:</span></p><div class="code-block" data-lang="csharp">
// SendPortal stores value in context
public override void Process(GraphContext context)
{
    var value = this.GetInputValue&lt;object&gt;(&quot;value&quot;, context);
    var portalId = this.GetOptionValue&lt;string&gt;(&quot;portalId&quot;);

    // Store with portal key
    context.SetValue($&quot;portal.{portalId}&quot;, value);
}

// ReceivePortal retrieves value
public override void Process(GraphContext context)
{
    var portalId = this.GetOptionValue&lt;string&gt;(&quot;portalId&quot;);
    var value = context.GetValue&lt;object&gt;($&quot;portal.{portalId}&quot;);

    this.SetOutputValue(&quot;value&quot;, value, context);
}
</div></section></section><section class="chapter"><h2 id="type-system" data-toc="type-system">Type System</h2><section class="chapter"><h3 id="type-compatibility" data-toc="type-compatibility">Type Compatibility</h3><p id="-6qkyo6_383"><span class="control" id="-6qkyo6_388">Purpose</span>: Determine if output type can connect to input type</p><p id="-6qkyo6_384"><span class="control" id="-6qkyo6_389">Scoring System:</span></p><div class="code-block" data-lang="csharp">
public static class TypeCompatibility
{
    public static int GetCompatibilityScore(Type outputType, Type inputType)
    {
        // Exact match
        if (outputType == inputType) return 100;

        // Input accepts object/Any
        if (inputType == typeof(object)) return 10;

        // Output is object (compatible with anything)
        if (outputType == typeof(object)) return 5;

        // Inheritance
        if (inputType.IsAssignableFrom(outputType))
        {
            int distance = GetInheritanceDistance(outputType, inputType);
            return 90 - distance * 5;
        }

        // Numeric conversions
        if (AreNumericTypes(outputType, inputType)) return 50;

        // Custom converters
        if (HasConverter(outputType, inputType)) return 30;

        // Incompatible
        return 0;
    }

    public static bool AreCompatible(Type outputType, Type inputType)
    {
        return GetCompatibilityScore(outputType, inputType) &gt; 0;
    }
}
</div><p id="-6qkyo6_386"><span class="control" id="-6qkyo6_390">Use Cases:</span></p><ul class="list _bullet" id="-6qkyo6_387"><li class="list__item" id="-6qkyo6_391"><p id="-6qkyo6_394">Port connection validation in editor</p></li><li class="list__item" id="-6qkyo6_392"><p id="-6qkyo6_395">Best-match selection in search window</p></li><li class="list__item" id="-6qkyo6_393"><p id="-6qkyo6_396">Runtime value conversion</p></li></ul></section><section class="chapter"><h3 id="custom-type-converters" data-toc="custom-type-converters">Custom Type Converters</h3><p id="-6qkyo6_397"><span class="control" id="-6qkyo6_401">Registration:</span></p><div class="code-block" data-lang="csharp">
TypeCompatibility.RegisterConverter&lt;Vector3, float&gt;(
    v =&gt; v.magnitude
);

TypeCompatibility.RegisterConverter&lt;Transform, GameObject&gt;(
    t =&gt; t.gameObject
);
</div><p id="-6qkyo6_399"><span class="control" id="-6qkyo6_402">Conversion:</span></p><div class="code-block" data-lang="csharp">
public static object Convert(object value, Type targetType)
{
    if (value == null) return null;

    var sourceType = value.GetType();

    // Check for converter
    if (TryGetConverter(sourceType, targetType, out var converter))
    {
        return converter(value);
    }

    // Fallback to System.Convert
    return System.Convert.ChangeType(value, targetType);
}
</div></section></section><section class="chapter"><h2 id="editor-backend-architecture" data-toc="editor-backend-architecture">Editor Backend Architecture</h2><section class="chapter"><h3 id="backend-interface" data-toc="backend-interface">Backend Interface</h3><p id="-6qkyo6_405"><span class="control" id="-6qkyo6_407">Purpose</span>: Abstract visual editor implementation</p><div class="code-block" data-lang="csharp">
public interface IGraphEditorBackend
{
    GraphAsset CurrentGraph { get; }

    void Initialize(EditorWindow window, VisualElement root);
    void LoadGraph(GraphAsset graph);
    void OnDisable();
}
</div></section><section class="chapter"><h3 id="graphview-backend" data-toc="graphview-backend">GraphView Backend</h3><p id="-6qkyo6_408"><span class="control" id="-6qkyo6_412">Components:</span></p><div class="code-block" data-lang="none">
GraphViewEditorBackend
├─ InteropGraphView (main canvas)
│   ├─ InteropNodeView (node visualization)
│   │   ├─ InteropPort (port visualization)
│   │   └─ Option fields (embedded UI)
│   └─ Edge (connection visualization)
├─ InteropBlackboard (parameter panel)
│   └─ BlackboardRow (parameter item)
├─ InteropInspector (selection details)
└─ NodeSearchWindow (node creation)
</div><p id="-6qkyo6_410"><span class="control" id="-6qkyo6_413">Synchronization:</span></p><div class="code-block" data-lang="csharp">
// Model → View
public void LoadGraph(GraphAsset graph)
{
    _graphView.Clear();

    // Create node views
    foreach (var node in graph.Nodes)
    {
        var nodeView = new InteropNodeView(node);
        _graphView.AddElement(nodeView);
    }

    // Create edge views
    foreach (var connection in graph.Connections)
    {
        var edge = CreateEdge(connection);
        _graphView.AddElement(edge);
    }
}

// View → Model
private void OnEdgeCreated(Edge edge)
{
    var connection = new Connection
    {
        SourceNodeId = (edge.output.node as InteropNodeView).NodeModel.Id,
        SourcePortName = (edge.output as InteropPort).PortModel.name,
        TargetNodeId = (edge.input.node as InteropNodeView).NodeModel.Id,
        TargetPortName = (edge.input as InteropPort).PortModel.name
    };

    _graph.Connections.Add(connection);
    EditorUtility.SetDirty(_graph);
}
</div></section></section><section class="chapter"><h2 id="performance-considerations" data-toc="performance-considerations">Performance Considerations</h2><section class="chapter"><h3 id="lazy-port-definition" data-toc="lazy-port-definition">Lazy Port Definition</h3><p id="-6qkyo6_417"><span class="control" id="-6qkyo6_420">Problem</span>: Creating ports for all nodes upfront is expensive</p><p id="-6qkyo6_418"><span class="control" id="-6qkyo6_421">Solution</span>: Define ports on first access</p><div class="code-block" data-lang="csharp">
private bool _portsInitialized;

public IEnumerable&lt;IPort&gt; GetInputPorts()
{
    if (!_portsInitialized)
    {
        DefineNode();
        _portsInitialized = true;
    }

    return _inputPorts;
}
</div></section><section class="chapter"><h3 id="connection-lookup-optimization" data-toc="connection-lookup-optimization">Connection Lookup Optimization</h3><p id="-6qkyo6_422"><span class="control" id="-6qkyo6_425">Problem</span>: Linear search through connections is slow for large graphs</p><p id="-6qkyo6_423"><span class="control" id="-6qkyo6_426">Solution</span>: Build connection index</p><div class="code-block" data-lang="csharp">
private Dictionary&lt;string, List&lt;Connection&gt;&gt; _inputConnectionCache;

private void BuildConnectionCache()
{
    _inputConnectionCache = new Dictionary&lt;string, List&lt;Connection&gt;&gt;();

    foreach (var connection in _graph.Connections)
    {
        var key = $&quot;{connection.TargetNodeId}.{connection.TargetPortName}&quot;;

        if (!_inputConnectionCache.ContainsKey(key))
            _inputConnectionCache[key] = new List&lt;Connection&gt;();

        _inputConnectionCache[key].Add(connection);
    }
}
</div></section><section class="chapter"><h3 id="value-caching" data-toc="value-caching">Value Caching</h3><p id="-6qkyo6_427"><span class="control" id="-6qkyo6_430">Problem</span>: Recalculating node outputs for each downstream node is wasteful</p><p id="-6qkyo6_428"><span class="control" id="-6qkyo6_431">Solution</span>: Cache outputs in context</p><div class="code-block" data-lang="csharp">
// Execute node once
node.Process(context);

// Cache all outputs
foreach (var port in node.GetOutputPorts())
{
    var value = /* get output value */;
    context.SetValue($&quot;{node.Id}.{port.name}&quot;, value);
}

// Downstream nodes reuse cached value
var inputValue = context.GetValue&lt;float&gt;($&quot;{sourceNodeId}.{sourcePortName}&quot;);
</div></section></section><section class="chapter"><h2 id="thread-safety" data-toc="thread-safety">Thread Safety</h2><div class="table-wrapper"><table class="wide" id="-6qkyo6_432"><thead><tr class="ijRowHead" id="-6qkyo6_435"><th id="-6qkyo6_441"><p>Component</p></th><th id="-6qkyo6_442"><p>Thread-Safe?</p></th><th id="-6qkyo6_443"><p>Notes</p></th></tr></thead><tbody><tr id="-6qkyo6_436"><td id="-6qkyo6_444"><p><code class="code" id="-6qkyo6_447">GraphAsset</code></p></td><td id="-6qkyo6_445"><p>❌</p></td><td id="-6qkyo6_446"><p>Modify on main thread only</p></td></tr><tr id="-6qkyo6_437"><td id="-6qkyo6_448"><p><code class="code" id="-6qkyo6_451">GraphExecutor</code></p></td><td id="-6qkyo6_449"><p>❌</p></td><td id="-6qkyo6_450"><p>Execute on main thread only</p></td></tr><tr id="-6qkyo6_438"><td id="-6qkyo6_452"><p><code class="code" id="-6qkyo6_455">GraphContext</code></p></td><td id="-6qkyo6_453"><p>❌</p></td><td id="-6qkyo6_454"><p>Single-threaded use only</p></td></tr><tr id="-6qkyo6_439"><td id="-6qkyo6_456"><p><code class="code" id="-6qkyo6_459">TypeCompatibility</code></p></td><td id="-6qkyo6_457"><p>✅</p></td><td id="-6qkyo6_458"><p>Static methods are thread-safe</p></td></tr><tr id="-6qkyo6_440"><td id="-6qkyo6_460"><p><code class="code" id="-6qkyo6_463">PortDefinition</code></p></td><td id="-6qkyo6_461"><p>⚠️</p></td><td id="-6qkyo6_462"><p>Read-only after initialization</p></td></tr></tbody></table></div><p id="-6qkyo6_433"><span class="control" id="-6qkyo6_464">Burst Nodes Exception:</span></p><div class="code-block" data-lang="csharp">
// Burst jobs run on worker threads
public JobHandle ScheduleBurstJob(GraphContext context)
{
    // Prepare data on main thread
    _input[0] = this.GetInputValue&lt;float&gt;(&quot;value&quot;, context);

    // Schedule job (runs on worker thread)
    return new MyJob { Input = _input }.Schedule();
}

public void CompleteBurstJob(GraphContext context)
{
    // Retrieve results on main thread
    this.SetOutputValue(&quot;result&quot;, _output[0], context);
}
</div></section><section class="chapter"><h2 id="memory-management" data-toc="memory-management">Memory Management</h2><section class="chapter"><h3 id="scriptableobject-lifecycle" data-toc="scriptableobject-lifecycle">ScriptableObject Lifecycle</h3><p id="-6qkyo6_467"><span class="control" id="-6qkyo6_473">Nodes are ScriptableObjects:</span></p><div class="code-block" data-lang="csharp">
// Creation
var node = ScriptableObject.CreateInstance&lt;MyNode&gt;();
node.hideFlags = HideFlags.HideInHierarchy; // Not shown in hierarchy

// Addition to graph
graph.Nodes.Add(node);
AssetDatabase.AddObjectToAsset(node, graph); // Becomes sub-asset

// Removal
graph.Nodes.Remove(node);
AssetDatabase.RemoveObjectFromAsset(node);
DestroyImmediate(node);
</div><p id="-6qkyo6_469"><span class="control" id="-6qkyo6_474">Benefits:</span></p><ul class="list _bullet" id="-6qkyo6_470"><li class="list__item" id="-6qkyo6_475"><p id="-6qkyo6_479">Unity handles serialization</p></li><li class="list__item" id="-6qkyo6_476"><p id="-6qkyo6_480">Inspector integration</p></li><li class="list__item" id="-6qkyo6_477"><p id="-6qkyo6_481">Undo/redo support (future)</p></li><li class="list__item" id="-6qkyo6_478"><p id="-6qkyo6_482">Asset database integration</p></li></ul><p id="-6qkyo6_471"><span class="control" id="-6qkyo6_483">Drawbacks:</span></p><ul class="list _bullet" id="-6qkyo6_472"><li class="list__item" id="-6qkyo6_484"><p id="-6qkyo6_487">Slightly slower than plain C# objects</p></li><li class="list__item" id="-6qkyo6_485"><p id="-6qkyo6_488">More memory overhead</p></li><li class="list__item" id="-6qkyo6_486"><p id="-6qkyo6_489">Requires editor API for creation/destruction</p></li></ul></section><section class="chapter"><h3 id="connection-storage" data-toc="connection-storage">Connection Storage</h3><p id="-6qkyo6_490"><span class="control" id="-6qkyo6_496">String IDs, Not Object References:</span></p><div class="code-block" data-lang="csharp">
// ✅ Good: String ID
public string SourceNodeId;

// ❌ Bad: Object reference
public GraphNode SourceNode; // Breaks on serialization
</div><p id="-6qkyo6_492"><span class="control" id="-6qkyo6_497">Benefits:</span></p><ul class="list _bullet" id="-6qkyo6_493"><li class="list__item" id="-6qkyo6_498"><p id="-6qkyo6_501">No broken references on node deletion</p></li><li class="list__item" id="-6qkyo6_499"><p id="-6qkyo6_502">Easy to serialize</p></li><li class="list__item" id="-6qkyo6_500"><p id="-6qkyo6_503">No circular dependencies</p></li></ul><p id="-6qkyo6_494"><span class="control" id="-6qkyo6_504">Drawbacks:</span></p><ul class="list _bullet" id="-6qkyo6_495"><li class="list__item" id="-6qkyo6_505"><p id="-6qkyo6_507">Requires lookup by ID (slightly slower)</p></li><li class="list__item" id="-6qkyo6_506"><p id="-6qkyo6_508">Need to maintain ID uniqueness</p></li></ul></section></section><section class="chapter"><h2 id="extension-points" data-toc="extension-points">Extension Points</h2><p id="-6qkyo6_509">GraphInterop is designed for extensibility:</p><ol class="list _decimal" id="-6qkyo6_510" type="1"><li class="list__item" id="-6qkyo6_512"><p id="-6qkyo6_518"><span class="control" id="-6qkyo6_519">Custom Nodes</span>: Subclass <code class="code" id="-6qkyo6_520">GraphNode</code></p></li><li class="list__item" id="-6qkyo6_513"><p id="-6qkyo6_521"><span class="control" id="-6qkyo6_522">Custom Graph Assets</span>: Subclass <code class="code" id="-6qkyo6_523">GraphAsset</code></p></li><li class="list__item" id="-6qkyo6_514"><p id="-6qkyo6_524"><span class="control" id="-6qkyo6_525">Custom Backends</span>: Implement <code class="code" id="-6qkyo6_526">IGraphEditorBackend</code></p></li><li class="list__item" id="-6qkyo6_515"><p id="-6qkyo6_527"><span class="control" id="-6qkyo6_528">Custom Type Converters</span>: Register via <code class="code" id="-6qkyo6_529">TypeCompatibility.RegisterConverter()</code></p></li><li class="list__item" id="-6qkyo6_516"><p id="-6qkyo6_530"><span class="control" id="-6qkyo6_531">Custom Port Builders</span>: Extend builder interfaces</p></li><li class="list__item" id="-6qkyo6_517"><p id="-6qkyo6_532"><span class="control" id="-6qkyo6_533">Custom Context Data</span>: Add data to <code class="code" id="-6qkyo6_534">GraphContext</code></p></li></ol><p id="-6qkyo6_511">See <a href="extensibility.html" id="-6qkyo6_535" data-tooltip="GraphInterop is designed to be extended and customized. This page covers all extension points and how to use them.">Extensibility</a> for details.</p></section><section class="chapter"><h2 id="summary" data-toc="summary">Summary</h2><p id="-6qkyo6_536">GraphInterop's architecture provides:</p><ul class="list _bullet" id="-6qkyo6_537"><li class="list__item" id="-6qkyo6_540"><p id="-6qkyo6_546">✅ Clean runtime/editor separation</p></li><li class="list__item" id="-6qkyo6_541"><p id="-6qkyo6_547">✅ Backend abstraction for future flexibility</p></li><li class="list__item" id="-6qkyo6_542"><p id="-6qkyo6_548">✅ GraphToolkit-compatible API</p></li><li class="list__item" id="-6qkyo6_543"><p id="-6qkyo6_549">✅ Type-safe port system</p></li><li class="list__item" id="-6qkyo6_544"><p id="-6qkyo6_550">✅ Efficient execution engine</p></li><li class="list__item" id="-6qkyo6_545"><p id="-6qkyo6_551">✅ Extensible design</p></li></ul><p id="-6qkyo6_538"><span class="control" id="-6qkyo6_552">Key Takeaways:</span></p><ol class="list _decimal" id="-6qkyo6_539" type="1"><li class="list__item" id="-6qkyo6_553"><p id="-6qkyo6_560">Runtime code has zero editor dependencies</p></li><li class="list__item" id="-6qkyo6_554"><p id="-6qkyo6_561">Backend can be switched without user code changes</p></li><li class="list__item" id="-6qkyo6_555"><p id="-6qkyo6_562">Nodes define ports via builder pattern (GTK-compatible)</p></li><li class="list__item" id="-6qkyo6_556"><p id="-6qkyo6_563">Graph execution uses topological sort for correctness</p></li><li class="list__item" id="-6qkyo6_557"><p id="-6qkyo6_564">Context carries data between nodes</p></li><li class="list__item" id="-6qkyo6_558"><p id="-6qkyo6_565">Type system supports custom conversions</p></li><li class="list__item" id="-6qkyo6_559"><p id="-6qkyo6_566">Architecture supports future GraphToolkit UI backend</p></li></ol></section><div class="last-modified">28 November 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="feature-roadmap.html" class="navigation-links__prev">Feature Roadmap</a><a href="extensibility.html" class="navigation-links__next">Extensibility</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.25.3-b857/app.js"></script></body></html>