<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#647A89"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-12-02T20:47:52.377199844"><title>Architecture | GraphInterop</title><script type="application/json" id="virtual-toc-data">[{"id":"overview","level":0,"title":"Overview","anchor":"#overview"},{"id":"high-level-architecture","level":0,"title":"High-Level Architecture","anchor":"#high-level-architecture"},{"id":"assembly-structure","level":0,"title":"Assembly Structure","anchor":"#assembly-structure"},{"id":"design-principles","level":0,"title":"Design Principles","anchor":"#design-principles"},{"id":"core-components","level":0,"title":"Core Components","anchor":"#core-components"},{"id":"data-flow","level":0,"title":"Data Flow","anchor":"#data-flow"},{"id":"type-system","level":0,"title":"Type System","anchor":"#type-system"},{"id":"editor-backend-architecture","level":0,"title":"Editor Backend Architecture","anchor":"#editor-backend-architecture"},{"id":"performance-considerations","level":0,"title":"Performance Considerations","anchor":"#performance-considerations"},{"id":"thread-safety","level":0,"title":"Thread Safety","anchor":"#thread-safety"},{"id":"memory-management","level":0,"title":"Memory Management","anchor":"#memory-management"},{"id":"extension-points","level":0,"title":"Extension Points","anchor":"#extension-points"},{"id":"summary","level":0,"title":"Summary","anchor":"#summary"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.25.3-b857/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Architecture | GraphInterop"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="GraphInterop Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/architecture.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Architecture | GraphInterop"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/architecture.html#webpage",
    "url": "writerside-documentation/architecture.html",
    "name": "Architecture | GraphInterop",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "GraphInterop Help"
}</script><!-- End Schema.org --></head><body data-id="architecture" data-main-title="Architecture" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>GraphInterop  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="architecture" id="architecture.md">Architecture</h1><p id="m9fhms_3">GraphInterop follows a layered architecture that separates runtime logic from editor visualization, enabling flexibility and maintainability.</p><section class="chapter"><h2 id="overview" data-toc="overview">Overview</h2><p id="m9fhms_17">GraphInterop's architecture is built on three core principles:</p><ol class="list _decimal" id="m9fhms_18" type="1"><li class="list__item" id="m9fhms_19"><p id="m9fhms_22"><span class="control" id="m9fhms_23">Runtime/Editor Separation</span>: Runtime graph execution has zero editor dependencies</p></li><li class="list__item" id="m9fhms_20"><p id="m9fhms_24"><span class="control" id="m9fhms_25">Backend Abstraction</span>: Multiple visual editors can be plugged in without changing user code</p></li><li class="list__item" id="m9fhms_21"><p id="m9fhms_26"><span class="control" id="m9fhms_27">GraphToolkit API Compatibility</span>: Runtime API mirrors Unity's GraphToolkit for future compatibility</p></li></ol></section><section class="chapter"><h2 id="high-level-architecture" data-toc="high-level-architecture">High-Level Architecture</h2><div class="code-block" data-lang="none">
┌─────────────────────────────────────────┐
│        User Code (Your Nodes)          │
│    MyCustomNode, GameLogicNode, etc.   │
└──────────────┬──────────────────────────┘
               │ depends on
               ▼
┌─────────────────────────────────────────┐
│      GraphInterop Runtime API           │
│  GraphAsset, GraphNode, GraphExecutor   │
│         (Semver-Stable API)             │
└──────────────┬──────────────────────────┘
               │
        ┌──────┴──────┐
        ▼             ▼
┌──────────────┐ ┌──────────────┐
│  GraphView   │ │ GraphToolkit │
│   Backend    │ │   Backend    │
│  (Current)   │ │   (Future)   │
└──────────────┘ └──────────────┘
</div><section class="chapter"><h3 id="key-insight" data-toc="key-insight">Key Insight</h3><p id="m9fhms_30">Your custom nodes only depend on the stable <code class="code" id="m9fhms_31">QhunGaming.GraphInterop</code> API. The visual backend (GraphView/GraphToolkit) can change without breaking your code.</p></section></section><section class="chapter"><h2 id="assembly-structure" data-toc="assembly-structure">Assembly Structure</h2><p id="m9fhms_32">GraphInterop consists of two assemblies:</p><section class="chapter"><h3 id="runtime-assembly" data-toc="runtime-assembly">Runtime Assembly</h3><p id="m9fhms_35"><span class="control" id="m9fhms_42">Name</span>: <code class="code" id="m9fhms_43">QhunGaming.GraphInterop</code></p><p id="m9fhms_36"><span class="control" id="m9fhms_44">Purpose</span>: All graph execution logic, no editor dependencies</p><p id="m9fhms_37"><span class="control" id="m9fhms_45">Key Types:</span></p><ul class="list _bullet" id="m9fhms_38"><li class="list__item" id="m9fhms_46"><p id="m9fhms_53"><code class="code" id="m9fhms_54">GraphAsset</code> - Graph data container (ScriptableObject)</p></li><li class="list__item" id="m9fhms_47"><p id="m9fhms_55"><code class="code" id="m9fhms_56">GraphNode</code> - Base class for all nodes</p></li><li class="list__item" id="m9fhms_48"><p id="m9fhms_57"><code class="code" id="m9fhms_58">GraphExecutor</code> - Executes graphs</p></li><li class="list__item" id="m9fhms_49"><p id="m9fhms_59"><code class="code" id="m9fhms_60">GraphContext</code> - Execution context</p></li><li class="list__item" id="m9fhms_50"><p id="m9fhms_61"><code class="code" id="m9fhms_62">IPort</code>, <code class="code" id="m9fhms_63">INodeOption</code> - Port/option interfaces</p></li><li class="list__item" id="m9fhms_51"><p id="m9fhms_64">Port/Option builders - Fluent configuration API</p></li><li class="list__item" id="m9fhms_52"><p id="m9fhms_65"><code class="code" id="m9fhms_66">TypeCompatibility</code> - Type system utilities</p></li></ul><p id="m9fhms_39"><span class="control" id="m9fhms_67">Dependencies:</span></p><ul class="list _bullet" id="m9fhms_40"><li class="list__item" id="m9fhms_68"><p id="m9fhms_72">Unity Engine (runtime only)</p></li><li class="list__item" id="m9fhms_69"><p id="m9fhms_73">Unity Mathematics (optional, for Burst)</p></li><li class="list__item" id="m9fhms_70"><p id="m9fhms_74">Unity Burst (optional)</p></li><li class="list__item" id="m9fhms_71"><p id="m9fhms_75">Unity Addressables (optional, for async examples)</p></li></ul><p id="m9fhms_41"><span class="control" id="m9fhms_76">Platform</span>: All (works in builds and editor)</p></section><section class="chapter"><h3 id="editor-assembly" data-toc="editor-assembly">Editor Assembly</h3><p id="m9fhms_77"><span class="control" id="m9fhms_84">Name</span>: <code class="code" id="m9fhms_85">QhunGaming.GraphInterop.Editor</code></p><p id="m9fhms_78"><span class="control" id="m9fhms_86">Purpose</span>: Visual graph editing using GraphView</p><p id="m9fhms_79"><span class="control" id="m9fhms_87">Key Types:</span></p><ul class="list _bullet" id="m9fhms_80"><li class="list__item" id="m9fhms_88"><p id="m9fhms_96"><code class="code" id="m9fhms_97">GraphInteropEditorWindow</code> - Main editor window</p></li><li class="list__item" id="m9fhms_89"><p id="m9fhms_98"><code class="code" id="m9fhms_99">IGraphEditorBackend</code> - Backend abstraction interface</p></li><li class="list__item" id="m9fhms_90"><p id="m9fhms_100"><code class="code" id="m9fhms_101">GraphViewEditorBackend</code> - GraphView implementation</p></li><li class="list__item" id="m9fhms_91"><p id="m9fhms_102"><code class="code" id="m9fhms_103">InteropGraphView</code> - GraphView subclass</p></li><li class="list__item" id="m9fhms_92"><p id="m9fhms_104"><code class="code" id="m9fhms_105">InteropNodeView</code> - Node visualization</p></li><li class="list__item" id="m9fhms_93"><p id="m9fhms_106"><code class="code" id="m9fhms_107">InteropPort</code> - Port visualization</p></li><li class="list__item" id="m9fhms_94"><p id="m9fhms_108"><code class="code" id="m9fhms_109">InteropBlackboard</code> - Parameter panel</p></li><li class="list__item" id="m9fhms_95"><p id="m9fhms_110"><code class="code" id="m9fhms_111">InteropInspector</code> - Selection details panel</p></li></ul><p id="m9fhms_81"><span class="control" id="m9fhms_112">Dependencies:</span></p><ul class="list _bullet" id="m9fhms_82"><li class="list__item" id="m9fhms_113"><p id="m9fhms_117">Runtime assembly</p></li><li class="list__item" id="m9fhms_114"><p id="m9fhms_118">Unity Editor</p></li><li class="list__item" id="m9fhms_115"><p id="m9fhms_119">Unity UIElements</p></li><li class="list__item" id="m9fhms_116"><p id="m9fhms_120">GraphView (part of UIElements)</p></li></ul><p id="m9fhms_83"><span class="control" id="m9fhms_121">Platform</span>: Editor only</p></section></section><section class="chapter"><h2 id="design-principles" data-toc="design-principles">Design Principles</h2><section class="chapter"><h3 id="1-runtime-editor-separation" data-toc="1-runtime-editor-separation">1. Runtime/Editor Separation</h3><p id="m9fhms_125"><span class="control" id="m9fhms_130">Goal</span>: Graphs can execute in builds without editor dependencies</p><p id="m9fhms_126"><span class="control" id="m9fhms_131">Implementation:</span></p><div class="code-block" data-lang="csharp">
// Runtime assembly (no editor dependencies)
namespace QhunGaming.GraphInterop
{
    public abstract class GraphNode : ScriptableObject
    {
        public abstract void Process(GraphContext context);
    }
}

// Editor assembly (uses UnityEditor)
#if UNITY_EDITOR
namespace QhunGaming.GraphInterop.Editor
{
    public class InteropNodeView : Node
    {
        public InteropNodeView(GraphNode model) { }
    }
}
#endif
</div><p id="m9fhms_128"><span class="control" id="m9fhms_132">Benefits:</span></p><ul class="list _bullet" id="m9fhms_129"><li class="list__item" id="m9fhms_133"><p id="m9fhms_137">Graphs run in builds</p></li><li class="list__item" id="m9fhms_134"><p id="m9fhms_138">No editor bloat in builds</p></li><li class="list__item" id="m9fhms_135"><p id="m9fhms_139">Faster build times</p></li><li class="list__item" id="m9fhms_136"><p id="m9fhms_140">Smaller binary size</p></li></ul></section><section class="chapter"><h3 id="2-backend-abstraction" data-toc="2-backend-abstraction">2. Backend Abstraction</h3><p id="m9fhms_141"><span class="control" id="m9fhms_146">Goal</span>: Support multiple visual editors (GraphView, GraphToolkit, custom)</p><p id="m9fhms_142"><span class="control" id="m9fhms_147">Implementation:</span></p><div class="code-block" data-lang="csharp">
public interface IGraphEditorBackend
{
    GraphAsset CurrentGraph { get; }
    void Initialize(EditorWindow window, VisualElement root);
    void LoadGraph(GraphAsset graph);
    void OnDisable();
}

// GraphView implementation
public class GraphViewEditorBackend : IGraphEditorBackend { }

// Future GraphToolkit implementation
public class GraphToolkitEditorBackend : IGraphEditorBackend { }

// Registration (factory pattern)
[InitializeOnLoadMethod]
private static void RegisterBackends()
{
    GraphInteropEditorWindow.RegisterBackend(() =&gt; new GraphViewEditorBackend());
}
</div><p id="m9fhms_144"><span class="control" id="m9fhms_148">Benefits:</span></p><ul class="list _bullet" id="m9fhms_145"><li class="list__item" id="m9fhms_149"><p id="m9fhms_153">Easy to switch backends</p></li><li class="list__item" id="m9fhms_150"><p id="m9fhms_154">Future-proof (when GraphToolkit UI matures)</p></li><li class="list__item" id="m9fhms_151"><p id="m9fhms_155">Custom editors possible</p></li><li class="list__item" id="m9fhms_152"><p id="m9fhms_156">No user code changes needed</p></li></ul></section><section class="chapter"><h3 id="3-graphtoolkit-api-compatibility" data-toc="3-graphtoolkit-api-compatibility">3. GraphToolkit API Compatibility</h3><p id="m9fhms_157"><span class="control" id="m9fhms_162">Goal</span>: Match GraphToolkit's API design for familiarity and future migration</p><p id="m9fhms_158"><span class="control" id="m9fhms_163">Comparison:</span></p><div class="table-wrapper"><table class="wide" id="m9fhms_159"><thead><tr class="ijRowHead" id="m9fhms_164"><th id="m9fhms_170"><p>Aspect</p></th><th id="m9fhms_171"><p>GraphToolkit</p></th><th id="m9fhms_172"><p>GraphInterop</p></th></tr></thead><tbody><tr id="m9fhms_165"><td id="m9fhms_173"><p>Graph container</p></td><td id="m9fhms_174"><p><code class="code" id="m9fhms_176">Graph</code> (abstract)</p></td><td id="m9fhms_175"><p><code class="code" id="m9fhms_177">GraphAsset</code> (concrete ScriptableObject)</p></td></tr><tr id="m9fhms_166"><td id="m9fhms_178"><p>Node definition</p></td><td id="m9fhms_179"><p><code class="code" id="m9fhms_181">OnDefinePorts()</code></p></td><td id="m9fhms_180"><p><code class="code" id="m9fhms_182">OnDefinePorts()</code> ✅ Same</p></td></tr><tr id="m9fhms_167"><td id="m9fhms_183"><p>Port builders</p></td><td id="m9fhms_184"><p><code class="code" id="m9fhms_186">IPortBuilder&lt;T&gt;</code></p></td><td id="m9fhms_185"><p><code class="code" id="m9fhms_187">IPortBuilder&lt;T&gt;</code> ✅ Same</p></td></tr><tr id="m9fhms_168"><td id="m9fhms_188"><p>Options</p></td><td id="m9fhms_189"><p><code class="code" id="m9fhms_191">INodeOption</code></p></td><td id="m9fhms_190"><p><code class="code" id="m9fhms_192">INodeOption</code> ✅ Same</p></td></tr><tr id="m9fhms_169"><td id="m9fhms_193"><p>Variables</p></td><td id="m9fhms_194"><p><code class="code" id="m9fhms_196">IVariable</code></p></td><td id="m9fhms_195"><p><code class="code" id="m9fhms_197">GraphParameter</code> (similar)</p></td></tr></tbody></table></div><p id="m9fhms_160"><span class="control" id="m9fhms_198">Benefits:</span></p><ul class="list _bullet" id="m9fhms_161"><li class="list__item" id="m9fhms_199"><p id="m9fhms_203">Familiar API for GTK users</p></li><li class="list__item" id="m9fhms_200"><p id="m9fhms_204">Easier future migration</p></li><li class="list__item" id="m9fhms_201"><p id="m9fhms_205">Consistent patterns</p></li><li class="list__item" id="m9fhms_202"><p id="m9fhms_206">Official Unity direction</p></li></ul></section></section><section class="chapter"><h2 id="core-components" data-toc="core-components">Core Components</h2><section class="chapter"><h3 id="graphasset-graph-data-model" data-toc="graphasset-graph-data-model">GraphAsset (Graph Data Model)</h3><p id="m9fhms_212"><span class="control" id="m9fhms_219">Purpose</span>: Serializable container for graph structure</p><p id="m9fhms_213"><span class="control" id="m9fhms_220">Responsibilities:</span></p><ul class="list _bullet" id="m9fhms_214"><li class="list__item" id="m9fhms_221"><p id="m9fhms_225">Store nodes, connections, parameters</p></li><li class="list__item" id="m9fhms_222"><p id="m9fhms_226">Validate graph structure</p></li><li class="list__item" id="m9fhms_223"><p id="m9fhms_227">Define context variables</p></li><li class="list__item" id="m9fhms_224"><p id="m9fhms_228">Provide CRUD operations</p></li></ul><p id="m9fhms_215"><span class="control" id="m9fhms_229">Key Properties:</span></p><div class="code-block" data-lang="csharp">
public class GraphAsset : ScriptableObject
{
    // Node storage
    [SerializeReference] public List&lt;GraphNode&gt; Nodes;

    // Connection storage
    [SerializeField] public List&lt;Connection&gt; Connections;

    // Parameter storage
    [SerializeField] public Blackboard Blackboard;

    // Context variable definitions
    public virtual IEnumerable&lt;ContextVariableDefinition&gt; GetContextVariables();

    // Operations
    public T AddNode&lt;T&gt;() where T : GraphNode;
    public void RemoveNode(GraphNode node);
    public void Connect(GraphNode source, string sourcePort,
                       GraphNode target, string targetPort);
    public List&lt;string&gt; Validate();
}
</div><p id="m9fhms_217"><span class="control" id="m9fhms_230">Serialization:</span></p><ul class="list _bullet" id="m9fhms_218"><li class="list__item" id="m9fhms_231"><p id="m9fhms_234">Uses <code class="code" id="m9fhms_235">[SerializeReference]</code> for polymorphic nodes</p></li><li class="list__item" id="m9fhms_232"><p id="m9fhms_236">Connection stored by node ID (string references)</p></li><li class="list__item" id="m9fhms_233"><p id="m9fhms_237">ScriptableObject for Unity asset integration</p></li></ul></section><section class="chapter"><h3 id="graphnode-node-definition" data-toc="graphnode-node-definition">GraphNode (Node Definition)</h3><p id="m9fhms_238"><span class="control" id="m9fhms_245">Purpose</span>: Base class for all custom nodes</p><p id="m9fhms_239"><span class="control" id="m9fhms_246">Responsibilities:</span></p><ul class="list _bullet" id="m9fhms_240"><li class="list__item" id="m9fhms_247"><p id="m9fhms_250">Define ports via builder pattern</p></li><li class="list__item" id="m9fhms_248"><p id="m9fhms_251">Define options via builder pattern</p></li><li class="list__item" id="m9fhms_249"><p id="m9fhms_252">Execute logic in <code class="code" id="m9fhms_253">Process()</code></p></li></ul><p id="m9fhms_241"><span class="control" id="m9fhms_254">Key Methods:</span></p><div class="code-block" data-lang="csharp">
public abstract class GraphNode : ScriptableObject
{
    // Unique identifier
    public string Id { get; internal set; }

    // Editor position (not used at runtime)
    public Vector2 EditorPosition { get; set; }

    // Port definition (builder pattern)
    protected virtual void OnDefinePorts(IPortDefinitionContext context) { }

    // Option definition (builder pattern)
    protected virtual void OnDefineOptions(IOptionDefinitionContext context) { }

    // Execution (override in subclasses)
    public abstract void Process(GraphContext context);

    // Port access
    public IPort GetInputPort(string name);
    public IPort GetOutputPort(string name);
    public IEnumerable&lt;IPort&gt; GetInputPorts();
    public IEnumerable&lt;IPort&gt; GetOutputPorts();

    // Option access
    public INodeOption GetNodeOption(string name);
    public T GetOptionValue&lt;T&gt;(string name);

    // Lifecycle
    public virtual void OnEnable() { }
    public virtual void OnDisable() { }

    // Validation
    public virtual void Validate(List&lt;string&gt; errors) { }
}
</div><p id="m9fhms_243"><span class="control" id="m9fhms_255">Lifecycle:</span></p><ol class="list _decimal" id="m9fhms_244" type="1"><li class="list__item" id="m9fhms_256"><p id="m9fhms_260"><span class="control" id="m9fhms_261">Creation</span>: <code class="code" id="m9fhms_262">graph.AddNode&lt;T&gt;()</code> &rarr; ScriptableObject.CreateInstance</p></li><li class="list__item" id="m9fhms_257"><p id="m9fhms_263"><span class="control" id="m9fhms_264">Definition</span>: First port/option access &rarr; <code class="code" id="m9fhms_265">OnDefinePorts()</code>/<code class="code" id="m9fhms_266">OnDefineOptions()</code></p></li><li class="list__item" id="m9fhms_258"><p id="m9fhms_267"><span class="control" id="m9fhms_268">Execution</span>: <code class="code" id="m9fhms_269">GraphExecutor</code> calls <code class="code" id="m9fhms_270">Process(context)</code></p></li><li class="list__item" id="m9fhms_259"><p id="m9fhms_271"><span class="control" id="m9fhms_272">Destruction</span>: Removed from graph &rarr; DestroyImmediate</p></li></ol></section><section class="chapter"><h3 id="port-system" data-toc="port-system">Port System</h3><p id="m9fhms_273"><span class="control" id="m9fhms_282">Purpose</span>: Type-safe input/output definition</p><p id="m9fhms_274"><span class="control" id="m9fhms_283">Key Interfaces:</span></p><div class="code-block" data-lang="csharp">
public interface IPort
{
    string name { get; }
    string displayName { get; }
    Type dataType { get; }
    PortDirection direction { get; }
    bool isConnected { get; }
    object DefaultValue { get; }
    object EmbeddedValue { get; set; }
}

public enum PortDirection
{
    Input,
    Output
}
</div><p id="m9fhms_276"><span class="control" id="m9fhms_284">Builder Pattern:</span></p><div class="code-block" data-lang="csharp">
// Input port builder
public interface IInputPortBuilder&lt;T&gt; : IInputPortBuilder
{
    IInputPortBuilder&lt;T&gt; WithDisplayName(string displayName);
    IInputPortBuilder&lt;T&gt; WithDefaultValue(T defaultValue);
    IInputPortBuilder&lt;T&gt; Required();
    void Build();
}

// Output port builder
public interface IOutputPortBuilder&lt;T&gt; : IOutputPortBuilder
{
    IOutputPortBuilder&lt;T&gt; WithDisplayName(string displayName);
    void Build();
}
</div><p id="m9fhms_278"><span class="control" id="m9fhms_285">Port Definition Context:</span></p><div class="code-block" data-lang="csharp">
public interface IPortDefinitionContext
{
    IInputPortBuilder&lt;T&gt; AddInputPort&lt;T&gt;(string name);
    IInputPortBuilder AddInputPort(string name);
    IOutputPortBuilder&lt;T&gt; AddOutputPort&lt;T&gt;(string name);
    IOutputPortBuilder AddOutputPort(string name);
}
</div><p id="m9fhms_280"><span class="control" id="m9fhms_286">Usage Example:</span></p><div class="code-block" data-lang="csharp">
protected override void OnDefinePorts(IPortDefinitionContext context)
{
    context.AddInputPort&lt;float&gt;(&quot;speed&quot;)
        .WithDisplayName(&quot;Movement Speed&quot;)
        .WithDefaultValue(5.0f)
        .Required()
        .Build();

    context.AddOutputPort&lt;Vector3&gt;(&quot;velocity&quot;)
        .WithDisplayName(&quot;Velocity&quot;)
        .Build();
}
</div></section><section class="chapter"><h3 id="graphexecutor-execution-engine" data-toc="graphexecutor-execution-engine">GraphExecutor (Execution Engine)</h3><p id="m9fhms_287"><span class="control" id="m9fhms_296">Purpose</span>: Execute graphs in correct dependency order</p><p id="m9fhms_288"><span class="control" id="m9fhms_297">Responsibilities:</span></p><ul class="list _bullet" id="m9fhms_289"><li class="list__item" id="m9fhms_298"><p id="m9fhms_303">Topological sort of nodes</p></li><li class="list__item" id="m9fhms_299"><p id="m9fhms_304">Input value resolution</p></li><li class="list__item" id="m9fhms_300"><p id="m9fhms_305">Node execution (sync/async/Burst)</p></li><li class="list__item" id="m9fhms_301"><p id="m9fhms_306">Output value caching</p></li><li class="list__item" id="m9fhms_302"><p id="m9fhms_307">Error handling</p></li></ul><p id="m9fhms_290"><span class="control" id="m9fhms_308">Key Methods:</span></p><div class="code-block" data-lang="csharp">
public class GraphExecutor
{
    private readonly GraphAsset _graph;

    public GraphExecutor(GraphAsset graph) { _graph = graph; }

    // Execute graph
    public async Task ExecuteAsync(GraphContext context);

    // Topological sort (dependency order)
    private List&lt;GraphNode&gt; TopologicalSort();

    // Execute single node
    private async Task ExecuteNodeAsync(GraphNode node, GraphContext context);
}
</div><p id="m9fhms_292"><span class="control" id="m9fhms_309">Execution Flow:</span></p><section class="procedure-steps"><h3 id="execution-steps" data-toc="execution-steps">Graph Execution Steps</h3><ol class="list _decimal"><li class="list__item" id="m9fhms_310"><p><b id="m9fhms_314">Validation</b>: Check required inputs, cycles, context variables</p></li><li class="list__item" id="m9fhms_311"><p><b id="m9fhms_315">Topological Sort</b>: Order nodes by dependencies (includes portal dependencies)</p></li><li class="list__item" id="m9fhms_312"><p><b id="m9fhms_316">For Each Node (in order)</b>: </p><ul class="list _bullet" id="m9fhms_317"><li class="list__item" id="m9fhms_318"><p>Resolve input values (from connections or defaults)</p></li><li class="list__item" id="m9fhms_319"><p>Execute node logic (sync/async/Burst)</p></li><li class="list__item" id="m9fhms_320"><p>Cache output values in context</p></li></ul></li><li class="list__item" id="m9fhms_313"><p><b id="m9fhms_321">Completion</b>: All nodes processed</p></li></ol></section><p id="m9fhms_294"><span class="control" id="m9fhms_322">Topological Sort Algorithm:</span></p><div class="code-block" data-lang="csharp">
private List&lt;GraphNode&gt; TopologicalSort()
{
    var sorted = new List&lt;GraphNode&gt;();
    var visited = new HashSet&lt;string&gt;();
    var visiting = new HashSet&lt;string&gt;();

    foreach (var node in _graph.Nodes)
    {
        Visit(node, visited, visiting, sorted);
    }

    return sorted;
}

private void Visit(GraphNode node, HashSet&lt;string&gt; visited,
                   HashSet&lt;string&gt; visiting, List&lt;GraphNode&gt; sorted)
{
    if (visited.Contains(node.Id)) return;

    if (visiting.Contains(node.Id))
        throw new Exception(&quot;Cycle detected&quot;);

    visiting.Add(node.Id);

    // Visit dependencies (nodes connected to inputs)
    foreach (var connection in GetInputConnections(node))
    {
        var dependency = GetNode(connection.SourceNodeId);
        Visit(dependency, visited, visiting, sorted);
    }

    visiting.Remove(node.Id);
    visited.Add(node.Id);
    sorted.Add(node);
}
</div></section><section class="chapter"><h3 id="graphcontext-execution-context" data-toc="graphcontext-execution-context">GraphContext (Execution Context)</h3><p id="m9fhms_323"><span class="control" id="m9fhms_330">Purpose</span>: Carry data and services between nodes during execution</p><p id="m9fhms_324"><span class="control" id="m9fhms_331">Responsibilities:</span></p><ul class="list _bullet" id="m9fhms_325"><li class="list__item" id="m9fhms_332"><p id="m9fhms_335">Store input/output values</p></li><li class="list__item" id="m9fhms_333"><p id="m9fhms_336">Provide context variables</p></li><li class="list__item" id="m9fhms_334"><p id="m9fhms_337">Carry services (graph asset, etc.)</p></li></ul><p id="m9fhms_326"><span class="control" id="m9fhms_338">Key Properties:</span></p><div class="code-block" data-lang="csharp">
public class GraphContext
{
    // Value storage (key: nodeId.portName)
    private Dictionary&lt;string, object&gt; _values;

    // Context variables (runtime-provided)
    private Dictionary&lt;string, object&gt; _contextVariables;

    // Set/get values
    public void SetValue(string key, object value);
    public T GetValue&lt;T&gt;(string key);
    public bool TryGetValue&lt;T&gt;(string key, out T value);

    // Context variables
    public void SetContextVariable(string name, object value);
    public T GetContextVariable&lt;T&gt;(string name);

    // Services
    public GraphAsset GraphAsset { get; set; }
}
</div><p id="m9fhms_328"><span class="control" id="m9fhms_339">Value Key Format:</span></p><div class="code-block" data-lang="csharp">
// Input values
$&quot;{nodeId}.{portName}.input&quot;

// Output values
$&quot;{nodeId}.{portName}&quot;

// Example
&quot;node_123.velocity.input&quot;  // Input value for 'velocity' port
&quot;node_123.result&quot;          // Output value for 'result' port
</div></section></section><section class="chapter"><h2 id="data-flow" data-toc="data-flow">Data Flow</h2><section class="chapter"><h3 id="connection-model" data-toc="connection-model">Connection Model</h3><p id="m9fhms_343"><span class="control" id="m9fhms_348">Purpose</span>: Represent edges between ports</p><p id="m9fhms_344"><span class="control" id="m9fhms_349">Structure:</span></p><div class="code-block" data-lang="csharp">
[Serializable]
public struct Connection
{
    public string SourceNodeId;    // Output node ID
    public string SourcePortName;  // Output port name
    public string TargetNodeId;    // Input node ID
    public string TargetPortName;  // Input port name
}
</div><p id="m9fhms_346"><span class="control" id="m9fhms_350">No Object References:</span></p><ul class="list _bullet" id="m9fhms_347"><li class="list__item" id="m9fhms_351"><p id="m9fhms_354">Connections store string IDs, not object references</p></li><li class="list__item" id="m9fhms_352"><p id="m9fhms_355">Allows serialization without breaking references</p></li><li class="list__item" id="m9fhms_353"><p id="m9fhms_356">Nodes can be destroyed/recreated safely</p></li></ul></section><section class="chapter"><h3 id="value-resolution" data-toc="value-resolution">Value Resolution</h3><p id="m9fhms_357"><span class="control" id="m9fhms_361">Priority Order (Highest to Lowest):</span></p><ol class="list _decimal" id="m9fhms_358" type="1"><li class="list__item" id="m9fhms_362"><p id="m9fhms_365"><span class="control" id="m9fhms_367">Connected Value</span> (from source node output)</p><div class="code-block" data-lang="csharp">
var connectionValue = context.GetValue&lt;float&gt;($&quot;{sourceNodeId}.{sourcePortName}&quot;);
</div></li><li class="list__item" id="m9fhms_363"><p id="m9fhms_368"><span class="control" id="m9fhms_370">Embedded Value</span> (user-set in editor)</p><div class="code-block" data-lang="csharp">
var embeddedValue = port.EmbeddedValue;
</div></li><li class="list__item" id="m9fhms_364"><p id="m9fhms_371"><span class="control" id="m9fhms_373">Default Value</span> (defined in port builder)</p><div class="code-block" data-lang="csharp">
var defaultValue = port.DefaultValue;
</div></li></ol><p id="m9fhms_359"><span class="control" id="m9fhms_374">Resolution Logic:</span></p><div class="code-block" data-lang="csharp">
private object ResolveInputValue(GraphNode node, IPort port, GraphContext context)
{
    // Check for connection
    var connection = _graph.Connections.FirstOrDefault(c =&gt;
        c.TargetNodeId == node.Id &amp;&amp; c.TargetPortName == port.name
    );

    if (connection != null)
    {
        // Use connected value
        var key = $&quot;{connection.SourceNodeId}.{connection.SourcePortName}&quot;;
        return context.GetValue&lt;object&gt;(key);
    }

    // Use embedded or default value
    return port.EmbeddedValue ?? port.DefaultValue;
}
</div></section><section class="chapter"><h3 id="portal-data-flow" data-toc="portal-data-flow">Portal Data Flow</h3><p id="m9fhms_375"><span class="control" id="m9fhms_379">Portal Dependency:</span></p><div class="code-block" data-lang="csharp">
// Before topological sort, add portal dependencies
foreach (var receivePortal in _graph.GetNodes&lt;ReceivePortalNode&gt;())
{
    var portalId = receivePortal.GetOptionValue&lt;string&gt;(&quot;portalId&quot;);
    var sendPortal = _graph.FindNode&lt;SendPortalNode&gt;(n =&gt;
        n.GetOptionValue&lt;string&gt;(&quot;portalId&quot;) == portalId
    );

    if (sendPortal != null)
    {
        // Ensure ReceivePortal depends on SendPortal
        AddVirtualDependency(receivePortal, sendPortal);
    }
}
</div><p id="m9fhms_377"><span class="control" id="m9fhms_380">Value Transfer:</span></p><div class="code-block" data-lang="csharp">
// SendPortal stores value in context
public override void Process(GraphContext context)
{
    var value = this.GetInputValue&lt;object&gt;(&quot;value&quot;, context);
    var portalId = this.GetOptionValue&lt;string&gt;(&quot;portalId&quot;);

    // Store with portal key
    context.SetValue($&quot;portal.{portalId}&quot;, value);
}

// ReceivePortal retrieves value
public override void Process(GraphContext context)
{
    var portalId = this.GetOptionValue&lt;string&gt;(&quot;portalId&quot;);
    var value = context.GetValue&lt;object&gt;($&quot;portal.{portalId}&quot;);

    this.SetOutputValue(&quot;value&quot;, value, context);
}
</div></section></section><section class="chapter"><h2 id="type-system" data-toc="type-system">Type System</h2><section class="chapter"><h3 id="type-compatibility" data-toc="type-compatibility">Type Compatibility</h3><p id="m9fhms_383"><span class="control" id="m9fhms_388">Purpose</span>: Determine if output type can connect to input type</p><p id="m9fhms_384"><span class="control" id="m9fhms_389">Scoring System:</span></p><div class="code-block" data-lang="csharp">
public static class TypeCompatibility
{
    public static int GetCompatibilityScore(Type outputType, Type inputType)
    {
        // Exact match
        if (outputType == inputType) return 100;

        // Input accepts object/Any
        if (inputType == typeof(object)) return 10;

        // Output is object (compatible with anything)
        if (outputType == typeof(object)) return 5;

        // Inheritance
        if (inputType.IsAssignableFrom(outputType))
        {
            int distance = GetInheritanceDistance(outputType, inputType);
            return 90 - distance * 5;
        }

        // Numeric conversions
        if (AreNumericTypes(outputType, inputType)) return 50;

        // Custom converters
        if (HasConverter(outputType, inputType)) return 30;

        // Incompatible
        return 0;
    }

    public static bool AreCompatible(Type outputType, Type inputType)
    {
        return GetCompatibilityScore(outputType, inputType) &gt; 0;
    }
}
</div><p id="m9fhms_386"><span class="control" id="m9fhms_390">Use Cases:</span></p><ul class="list _bullet" id="m9fhms_387"><li class="list__item" id="m9fhms_391"><p id="m9fhms_394">Port connection validation in editor</p></li><li class="list__item" id="m9fhms_392"><p id="m9fhms_395">Best-match selection in search window</p></li><li class="list__item" id="m9fhms_393"><p id="m9fhms_396">Runtime value conversion</p></li></ul></section><section class="chapter"><h3 id="custom-type-converters" data-toc="custom-type-converters">Custom Type Converters</h3><p id="m9fhms_397"><span class="control" id="m9fhms_401">Registration:</span></p><div class="code-block" data-lang="csharp">
TypeCompatibility.RegisterConverter&lt;Vector3, float&gt;(
    v =&gt; v.magnitude
);

TypeCompatibility.RegisterConverter&lt;Transform, GameObject&gt;(
    t =&gt; t.gameObject
);
</div><p id="m9fhms_399"><span class="control" id="m9fhms_402">Conversion:</span></p><div class="code-block" data-lang="csharp">
public static object Convert(object value, Type targetType)
{
    if (value == null) return null;

    var sourceType = value.GetType();

    // Check for converter
    if (TryGetConverter(sourceType, targetType, out var converter))
    {
        return converter(value);
    }

    // Fallback to System.Convert
    return System.Convert.ChangeType(value, targetType);
}
</div></section></section><section class="chapter"><h2 id="editor-backend-architecture" data-toc="editor-backend-architecture">Editor Backend Architecture</h2><section class="chapter"><h3 id="backend-interface" data-toc="backend-interface">Backend Interface</h3><p id="m9fhms_405"><span class="control" id="m9fhms_407">Purpose</span>: Abstract visual editor implementation</p><div class="code-block" data-lang="csharp">
public interface IGraphEditorBackend
{
    GraphAsset CurrentGraph { get; }

    void Initialize(EditorWindow window, VisualElement root);
    void LoadGraph(GraphAsset graph);
    void OnDisable();
}
</div></section><section class="chapter"><h3 id="graphview-backend" data-toc="graphview-backend">GraphView Backend</h3><p id="m9fhms_408"><span class="control" id="m9fhms_412">Components:</span></p><div class="code-block" data-lang="none">
GraphViewEditorBackend
├─ InteropGraphView (main canvas)
│   ├─ InteropNodeView (node visualization)
│   │   ├─ InteropPort (port visualization)
│   │   └─ Option fields (embedded UI)
│   └─ Edge (connection visualization)
├─ InteropBlackboard (parameter panel)
│   └─ BlackboardRow (parameter item)
├─ InteropInspector (selection details)
└─ NodeSearchWindow (node creation)
</div><p id="m9fhms_410"><span class="control" id="m9fhms_413">Synchronization:</span></p><div class="code-block" data-lang="csharp">
// Model → View
public void LoadGraph(GraphAsset graph)
{
    _graphView.Clear();

    // Create node views
    foreach (var node in graph.Nodes)
    {
        var nodeView = new InteropNodeView(node);
        _graphView.AddElement(nodeView);
    }

    // Create edge views
    foreach (var connection in graph.Connections)
    {
        var edge = CreateEdge(connection);
        _graphView.AddElement(edge);
    }
}

// View → Model
private void OnEdgeCreated(Edge edge)
{
    var connection = new Connection
    {
        SourceNodeId = (edge.output.node as InteropNodeView).NodeModel.Id,
        SourcePortName = (edge.output as InteropPort).PortModel.name,
        TargetNodeId = (edge.input.node as InteropNodeView).NodeModel.Id,
        TargetPortName = (edge.input as InteropPort).PortModel.name
    };

    _graph.Connections.Add(connection);
    EditorUtility.SetDirty(_graph);
}
</div></section></section><section class="chapter"><h2 id="performance-considerations" data-toc="performance-considerations">Performance Considerations</h2><section class="chapter"><h3 id="lazy-port-definition" data-toc="lazy-port-definition">Lazy Port Definition</h3><p id="m9fhms_417"><span class="control" id="m9fhms_420">Problem</span>: Creating ports for all nodes upfront is expensive</p><p id="m9fhms_418"><span class="control" id="m9fhms_421">Solution</span>: Define ports on first access</p><div class="code-block" data-lang="csharp">
private bool _portsInitialized;

public IEnumerable&lt;IPort&gt; GetInputPorts()
{
    if (!_portsInitialized)
    {
        DefineNode();
        _portsInitialized = true;
    }

    return _inputPorts;
}
</div></section><section class="chapter"><h3 id="connection-lookup-optimization" data-toc="connection-lookup-optimization">Connection Lookup Optimization</h3><p id="m9fhms_422"><span class="control" id="m9fhms_425">Problem</span>: Linear search through connections is slow for large graphs</p><p id="m9fhms_423"><span class="control" id="m9fhms_426">Solution</span>: Build connection index</p><div class="code-block" data-lang="csharp">
private Dictionary&lt;string, List&lt;Connection&gt;&gt; _inputConnectionCache;

private void BuildConnectionCache()
{
    _inputConnectionCache = new Dictionary&lt;string, List&lt;Connection&gt;&gt;();

    foreach (var connection in _graph.Connections)
    {
        var key = $&quot;{connection.TargetNodeId}.{connection.TargetPortName}&quot;;

        if (!_inputConnectionCache.ContainsKey(key))
            _inputConnectionCache[key] = new List&lt;Connection&gt;();

        _inputConnectionCache[key].Add(connection);
    }
}
</div></section><section class="chapter"><h3 id="value-caching" data-toc="value-caching">Value Caching</h3><p id="m9fhms_427"><span class="control" id="m9fhms_430">Problem</span>: Recalculating node outputs for each downstream node is wasteful</p><p id="m9fhms_428"><span class="control" id="m9fhms_431">Solution</span>: Cache outputs in context</p><div class="code-block" data-lang="csharp">
// Execute node once
node.Process(context);

// Cache all outputs
foreach (var port in node.GetOutputPorts())
{
    var value = /* get output value */;
    context.SetValue($&quot;{node.Id}.{port.name}&quot;, value);
}

// Downstream nodes reuse cached value
var inputValue = context.GetValue&lt;float&gt;($&quot;{sourceNodeId}.{sourcePortName}&quot;);
</div></section></section><section class="chapter"><h2 id="thread-safety" data-toc="thread-safety">Thread Safety</h2><div class="table-wrapper"><table class="wide" id="m9fhms_432"><thead><tr class="ijRowHead" id="m9fhms_435"><th id="m9fhms_441"><p>Component</p></th><th id="m9fhms_442"><p>Thread-Safe?</p></th><th id="m9fhms_443"><p>Notes</p></th></tr></thead><tbody><tr id="m9fhms_436"><td id="m9fhms_444"><p><code class="code" id="m9fhms_447">GraphAsset</code></p></td><td id="m9fhms_445"><p>❌</p></td><td id="m9fhms_446"><p>Modify on main thread only</p></td></tr><tr id="m9fhms_437"><td id="m9fhms_448"><p><code class="code" id="m9fhms_451">GraphExecutor</code></p></td><td id="m9fhms_449"><p>❌</p></td><td id="m9fhms_450"><p>Execute on main thread only</p></td></tr><tr id="m9fhms_438"><td id="m9fhms_452"><p><code class="code" id="m9fhms_455">GraphContext</code></p></td><td id="m9fhms_453"><p>❌</p></td><td id="m9fhms_454"><p>Single-threaded use only</p></td></tr><tr id="m9fhms_439"><td id="m9fhms_456"><p><code class="code" id="m9fhms_459">TypeCompatibility</code></p></td><td id="m9fhms_457"><p>✅</p></td><td id="m9fhms_458"><p>Static methods are thread-safe</p></td></tr><tr id="m9fhms_440"><td id="m9fhms_460"><p><code class="code" id="m9fhms_463">PortDefinition</code></p></td><td id="m9fhms_461"><p>⚠️</p></td><td id="m9fhms_462"><p>Read-only after initialization</p></td></tr></tbody></table></div><p id="m9fhms_433"><span class="control" id="m9fhms_464">Burst Nodes Exception:</span></p><div class="code-block" data-lang="csharp">
// Burst jobs run on worker threads
public JobHandle ScheduleBurstJob(GraphContext context)
{
    // Prepare data on main thread
    _input[0] = this.GetInputValue&lt;float&gt;(&quot;value&quot;, context);

    // Schedule job (runs on worker thread)
    return new MyJob { Input = _input }.Schedule();
}

public void CompleteBurstJob(GraphContext context)
{
    // Retrieve results on main thread
    this.SetOutputValue(&quot;result&quot;, _output[0], context);
}
</div></section><section class="chapter"><h2 id="memory-management" data-toc="memory-management">Memory Management</h2><section class="chapter"><h3 id="scriptableobject-lifecycle" data-toc="scriptableobject-lifecycle">ScriptableObject Lifecycle</h3><p id="m9fhms_467"><span class="control" id="m9fhms_473">Nodes are ScriptableObjects:</span></p><div class="code-block" data-lang="csharp">
// Creation
var node = ScriptableObject.CreateInstance&lt;MyNode&gt;();
node.hideFlags = HideFlags.HideInHierarchy; // Not shown in hierarchy

// Addition to graph
graph.Nodes.Add(node);
AssetDatabase.AddObjectToAsset(node, graph); // Becomes sub-asset

// Removal
graph.Nodes.Remove(node);
AssetDatabase.RemoveObjectFromAsset(node);
DestroyImmediate(node);
</div><p id="m9fhms_469"><span class="control" id="m9fhms_474">Benefits:</span></p><ul class="list _bullet" id="m9fhms_470"><li class="list__item" id="m9fhms_475"><p id="m9fhms_479">Unity handles serialization</p></li><li class="list__item" id="m9fhms_476"><p id="m9fhms_480">Inspector integration</p></li><li class="list__item" id="m9fhms_477"><p id="m9fhms_481">Undo/redo support (future)</p></li><li class="list__item" id="m9fhms_478"><p id="m9fhms_482">Asset database integration</p></li></ul><p id="m9fhms_471"><span class="control" id="m9fhms_483">Drawbacks:</span></p><ul class="list _bullet" id="m9fhms_472"><li class="list__item" id="m9fhms_484"><p id="m9fhms_487">Slightly slower than plain C# objects</p></li><li class="list__item" id="m9fhms_485"><p id="m9fhms_488">More memory overhead</p></li><li class="list__item" id="m9fhms_486"><p id="m9fhms_489">Requires editor API for creation/destruction</p></li></ul></section><section class="chapter"><h3 id="connection-storage" data-toc="connection-storage">Connection Storage</h3><p id="m9fhms_490"><span class="control" id="m9fhms_496">String IDs, Not Object References:</span></p><div class="code-block" data-lang="csharp">
// ✅ Good: String ID
public string SourceNodeId;

// ❌ Bad: Object reference
public GraphNode SourceNode; // Breaks on serialization
</div><p id="m9fhms_492"><span class="control" id="m9fhms_497">Benefits:</span></p><ul class="list _bullet" id="m9fhms_493"><li class="list__item" id="m9fhms_498"><p id="m9fhms_501">No broken references on node deletion</p></li><li class="list__item" id="m9fhms_499"><p id="m9fhms_502">Easy to serialize</p></li><li class="list__item" id="m9fhms_500"><p id="m9fhms_503">No circular dependencies</p></li></ul><p id="m9fhms_494"><span class="control" id="m9fhms_504">Drawbacks:</span></p><ul class="list _bullet" id="m9fhms_495"><li class="list__item" id="m9fhms_505"><p id="m9fhms_507">Requires lookup by ID (slightly slower)</p></li><li class="list__item" id="m9fhms_506"><p id="m9fhms_508">Need to maintain ID uniqueness</p></li></ul></section></section><section class="chapter"><h2 id="extension-points" data-toc="extension-points">Extension Points</h2><p id="m9fhms_509">GraphInterop is designed for extensibility:</p><ol class="list _decimal" id="m9fhms_510" type="1"><li class="list__item" id="m9fhms_512"><p id="m9fhms_518"><span class="control" id="m9fhms_519">Custom Nodes</span>: Subclass <code class="code" id="m9fhms_520">GraphNode</code></p></li><li class="list__item" id="m9fhms_513"><p id="m9fhms_521"><span class="control" id="m9fhms_522">Custom Graph Assets</span>: Subclass <code class="code" id="m9fhms_523">GraphAsset</code></p></li><li class="list__item" id="m9fhms_514"><p id="m9fhms_524"><span class="control" id="m9fhms_525">Custom Backends</span>: Implement <code class="code" id="m9fhms_526">IGraphEditorBackend</code></p></li><li class="list__item" id="m9fhms_515"><p id="m9fhms_527"><span class="control" id="m9fhms_528">Custom Type Converters</span>: Register via <code class="code" id="m9fhms_529">TypeCompatibility.RegisterConverter()</code></p></li><li class="list__item" id="m9fhms_516"><p id="m9fhms_530"><span class="control" id="m9fhms_531">Custom Port Builders</span>: Extend builder interfaces</p></li><li class="list__item" id="m9fhms_517"><p id="m9fhms_532"><span class="control" id="m9fhms_533">Custom Context Data</span>: Add data to <code class="code" id="m9fhms_534">GraphContext</code></p></li></ol><p id="m9fhms_511">See <a href="extensibility.html" id="m9fhms_535" data-tooltip="GraphInterop is designed to be extended and customized. This page covers all extension points and how to use them.">Extensibility</a> for details.</p></section><section class="chapter"><h2 id="summary" data-toc="summary">Summary</h2><p id="m9fhms_536">GraphInterop's architecture provides:</p><ul class="list _bullet" id="m9fhms_537"><li class="list__item" id="m9fhms_540"><p id="m9fhms_546">✅ Clean runtime/editor separation</p></li><li class="list__item" id="m9fhms_541"><p id="m9fhms_547">✅ Backend abstraction for future flexibility</p></li><li class="list__item" id="m9fhms_542"><p id="m9fhms_548">✅ GraphToolkit-compatible API</p></li><li class="list__item" id="m9fhms_543"><p id="m9fhms_549">✅ Type-safe port system</p></li><li class="list__item" id="m9fhms_544"><p id="m9fhms_550">✅ Efficient execution engine</p></li><li class="list__item" id="m9fhms_545"><p id="m9fhms_551">✅ Extensible design</p></li></ul><p id="m9fhms_538"><span class="control" id="m9fhms_552">Key Takeaways:</span></p><ol class="list _decimal" id="m9fhms_539" type="1"><li class="list__item" id="m9fhms_553"><p id="m9fhms_560">Runtime code has zero editor dependencies</p></li><li class="list__item" id="m9fhms_554"><p id="m9fhms_561">Backend can be switched without user code changes</p></li><li class="list__item" id="m9fhms_555"><p id="m9fhms_562">Nodes define ports via builder pattern (GTK-compatible)</p></li><li class="list__item" id="m9fhms_556"><p id="m9fhms_563">Graph execution uses topological sort for correctness</p></li><li class="list__item" id="m9fhms_557"><p id="m9fhms_564">Context carries data between nodes</p></li><li class="list__item" id="m9fhms_558"><p id="m9fhms_565">Type system supports custom conversions</p></li><li class="list__item" id="m9fhms_559"><p id="m9fhms_566">Architecture supports future GraphToolkit UI backend</p></li></ol></section><div class="last-modified">02 December 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="feature-roadmap.html" class="navigation-links__prev">Feature Roadmap</a><a href="extensibility.html" class="navigation-links__next">Extensibility</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.25.3-b857/app.js"></script></body></html>